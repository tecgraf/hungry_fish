import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:hungry_fish/graphic_config.dart';

/// Waves are automatically generated by calculating the sine wave.
///
/// The widget allows you to draw a wave near or far that will be defined by [near].
/// The [phase], specifies in radians the fraction of the cycle.
class WaveWidget extends StatelessWidget {
  const WaveWidget(
      {Key? key, required this.near, required this.phase, required this.config})
      : super(key: key);

  final GraphicConfig config;
  final bool near;
  final double phase;

  @override
  Widget build(BuildContext context) {
    Color color = near ? Colors.blue[400]!.withAlpha(200) : Colors.blue[700]!;
    if (config.drawPlaceholderOnly) {
      return Container(color: color);
    }
    return CustomPaint(
        painter: _WavePainter(
            near: near,
            color: color,
            phase: phase,
            debug: config.debugEnabled));
  }
}

class _WavePainter extends CustomPainter {
  _WavePainter(
      {required this.near,
      required this.color,
      required this.phase,
      required this.debug});

  final double debugX = 100;
  final bool near;
  final Color color;
  final double phase;
  final bool debug;

  @override
  void paint(Canvas canvas, Size size) {
    double waveHeight = near ? size.height * .3 : size.height * .1;
    double waveCenterY = waveHeight / 2;
    double amplitude = waveHeight / 2;
    int frequency = near ? 3 : 3;

    Path path = Path();

    path.moveTo(
        0,
        waveCenterY +
            amplitude *
                _y(
                    radius: phase,
                    frequency: frequency,
                    x: -1,
                    width: size.width));
    double debugY = 0;
    for (int x = 1; x < size.width + 1; x++) {
      double y = waveCenterY +
          amplitude *
              _y(radius: phase, frequency: frequency, x: x, width: size.width);
      path.lineTo(x.toDouble(), y);
      if (x == debugX) {
        debugY = y;
      }
    }

    path.lineTo(size.width, size.height);
    path.lineTo(0.0, size.height);
    path.close();

    Paint paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill
      ..color = color;
    canvas.drawPath(path, paint);

    if (debug && near) {
      paint = Paint()
        ..color = color
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = Colors.black;
      canvas.drawLine(
          Offset(0, waveCenterY), Offset(size.width, waveCenterY), paint);
      canvas.drawLine(
          Offset(debugX, waveCenterY), Offset(debugX, debugY), paint);
      canvas.drawCircle(Offset(debugX, waveCenterY), amplitude, paint);
    }
  }

  double _y(
      {required double radius,
      required int frequency,
      required int x,
      required double width}) {
    return math
        .sin(math.pi / width * frequency * x + radius * 2 * math.pi / 360.0);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return true;
  }
}
